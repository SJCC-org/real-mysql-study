# 4.2 InnoDB 스토리지 엔진 아키텍처

## 4.2.9 언두 로그

> InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업하는데 이 백업된 데이터를 언두 로그(Undo Log)라고 한다.

- `트랜잭션 보장`: 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구
- `격리 수준 보장`: 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 함

### 4.2.9.1 언두 로그 레코드 모니터링

#### 언두 로그 데이터 저장 방식

```sql
UPDATE member SET name='홍길동' WHERE member_id=1;
```

- 위 문장이 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일(데이터/인덱스 버퍼) 내용은 '홍길동'으로 변경
- 변경되기 전의 값이 '벽계수'였다면, 언두 영역에는 '벽계수'라는 값(변경되기 전의 값) 백업
- 커밋하면 현재 상태 유지
- 롤백하면 언두 영역의 백업된 데이터를 다시 데이터 파일로 복구

#### 대용량의 데이터를 처리하는 트랜잭션으로 인한 언두 로그 증가

1. 1억 건의 레코드가 저장된 100GB 크기의 테이블을 DELETE로 삭제
2. MySQL 서버는 이 테이블에서 레코드를 한 건 삭제하고 언두 로그에 삭제되기 전 값을 저장
3. 이렇게 1억 건의 레코드가 테이블에서는 삭제되지만 언두 로그로 복사 -> 테이블 크기 만큼 언두 로그의 공간 사용량이 늘어남

#### 장시간 유지되는 트랜잭션으로 인한 언두 로그 증가

A: `BEGIN`-`SELECT`--------------------------------------->  
B: ..........`BEGIN`-`UPDATE`-`COMMIT`  
C: ......................`BEGIN`-`DELETE`-`COMMIT`

- 트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는 것은 아님
- 위 예시와 같은 경우 B, C 트랜잭션은 완료됐지만 가장 먼저 시작된 트랜잭션 A는 아직 완료되지 않은 상태 -> B, C 트랜잭션 완료 여부와 관계없이 B, C 트랜잭션이 만들어낸 언두로그 삭제되지 않음

#### MySQL 5.7, 8.0 이후 언두 로그 사용공간

MySQL 5.5 버전까지는 언두 로그의 사용 공간이 한 번 늘어나면 서버를 새로 구축하지 않는 한 줄일 수가 없었음.  
5.7, 8.0으로 업그레이드되면서 언두 로그 공간의 문제점은 완전히 해결.

#### 언두 로그 레코드 건수 조회

```sql
-- MySQL 서버의 모든 버전에서 사용 가능한 명령
SHOW ENGINE INNODB STATUS \G;

-- MySQL 8.0 버전에서 사용 가능한 명령
SELECT count
FROM information_schema.innodb_metrics
WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len';
```

- MySQL 서버에서 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않으므로 언두 로그 레코드가 얼마나 되는지 항상 모니터링 하는 것이 좋음
- MySQL 서버별로 이 값은 차이를 보이는데, 서버별로 안정적인 시점의 언두 로그 레코드 건수를 확인해 이를 기준으로 언두 로그의 급증 여부를 모니터링

### 4.2.9.2 언두 테이블스페이스 관리

> `언두 테이블스페이스(Undo Tablespace)`: 언두 로그가 저장되는 공간

- `언두 테이블스페이스`는 1 ~ 128 개의 `롤백 세그먼트`를 가짐
- `롤백 세그먼트`는 1개 이상의 `언두 슬롯(Undo Slot)`을 가짐
- 하나의 `롤백 세그먼트`는 InnoDB의 페이지 크기를 16바이트로 나눈 값의 개수 만큼의 `언두 슬롯`을 가짐
- 하나의 트랜잭션이 필요로 하는 언두 슬롯의 개수는 트랜잭션이 실행하는 INSERT, UPDATE, DELETE 문장의 특성에 따라 최대 4개 까지 사용
  - 일반적으로는 트랜잭션이 임시 테이블을 사용하지 않으므로 하나의 트랜잭션은 대략 2개 정도의 언두 슬롯을 필요로 한다고 가정하면 됨
- 최대 동시 트랜잭션 수 = (InnoDB 페이지 크기) / 16 \* (롤백 세그먼트 개수) \* 언두 테이블 스페이스 개수
  - 131072 (= 16 \* 1024 / 16 \* 128 \* 2 / 2) 
  - 가장 일반 적인 설정인 16KB InnoDB에서 기본설정 (innodb_undo_tablespaces=2, innodb_rollback_segments=128) 을 사용할 때
  - 일반적이 서비스에서 이 정도까지 동시 트랜잭션이 필요하진 않겠지만 기본값으로 해서 크게 문제될 건 없으므로 가능하면 기본값 유지
- 언두 로그 공간이 남는 것은 크게 문제되지 않지만 언두 로그 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생
- 언두 로그 관련 시스템 변수를 변경해야 한다면 적절히 동시 트랜잭션 개수에 맞게 언두 테이블스페이스와 롤백 세그먼트의 개수를 설정
- MySQL 8.0 이전까지는 한 번 생성된 언두 로그는 변경이 허용되지 않고 정적으로 사용됐지만 8.0 부터는 새로운 언두 테이블스페이스를 동적으로 추가하고 삭제할 수 있게 됨

#### Undo tablespace truncate

> 언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제로 반납하는 것.  
> MySQL 8.0 부터 지원.

- `자동모드`
  - 트랜잭션이 커밋되면 더이상 언두 로그에 복사된 이전 값은 불필요
  - `Undo Purge`: InnoDB 스토리지 엔진의 퍼지 스레드(Purge Thread)는 주기적으로 깨어나서 언두 로그 공간에서 불필요해진 언두 로그를 삭제하는 작업 실행
  - `innodb_undo_log_truncate` 시스템 변수가 ON으로 설정되면, 퍼지 스레드는 주기적으로 언두 로그 파일에서 사용되지 않는 공간을 잘라내고 운영체제로 반납
  - 언두 로그 파일을 잘라내는 작업을 조졀하려면 `innodb_purge_rseg_truncate_frequency` 시스템 변수의 값을 조정
- `수동모드`
  - `innodb_undo_log_truncate` 시스템 변수가 OFF로 설정되어 언두 로그 파일의 잘라내기가 자동으로 실행되지 않거나 자동 모드로 언두 테이블스페이스의 공간 반납이 부진한 경우
  - 언두 테이블스페이스를 비활성화해서 언두 테이블 스페이스가 더이상 사용되지 않도록 설정하면 퍼지 스레드는 비활성 상태의 언두테이블스페이스를 찾아서 불필요한 공간을 잘라내고 운영체제로 해당 공간을 반납
  - 반납이 완료되면 언두 테이블스페이스를 다시 활성화
  - 언두 테이블스페이스가 최소 3개 이상이어야 작동

```sql
-- 언두 테이블스페이스 비활성화
ALTER UNDO TABLESPACE tablespace_name SET INACTIVE;

-- 퍼지 스레드에 의해 언두 테이블스페이스 공간이 반납되면 다시 활성화
ALTER UNDO TABLESPACE tablespace_name SET ACTIVE;
```

## 4.2.10 체인지 버퍼

> 변경해야 할 인덱스 페이지가 버퍼 풀에 없고, 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는데 이때 사용하는 임시 메모리 공간

- 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 사용할 수 없음
- `체인지 버퍼 머지 스레드`: 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각을 병합
- `innodb_change_buffering`: 작업의 종류별로 체인지 버퍼를 활성화하거나 체인지 버퍼가 비효율적일 떄는 비활성화
  - `all`: 모든 인덱스 관련 작업(inserts + deletes + purges)을 버퍼링
  - `none`: 버퍼링 안함
  - `inserts`: 인덱스에 새로운 아이템을 추가하는 작업만 버퍼링
  - `deletes`: 인덱스에서 기존 아이템을 삭제하는 작업(삭제됐다는 마킹 작업)만 버퍼링
  - `changes`: 인덱스에 추가하고 삭제하는 작업만(inserts + deletes) 버퍼링
  - `purges`: 인덱스 아이템을 영구적으로 삭제하는 작업만 버퍼링(백그라운드 작업)
- `innodb_change_buffer_max_size`: 체인지 버퍼 사이즈 조절

```sql
-- 체인지 버퍼가 사용 중인 메모리 공간의 크기
SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
FROM performance_schema.memory_summary_global_by_event_name
WHERE EVENT_NAME='memory/innodb/ibuf0ibuf';

-- 체인지 버퍼 관련 오퍼레이션 처리 횟수
SHOW ENGINE INNODB STATUS \G
```

# 5.2 MySQL 엔진의 잠금
- MySQL에서 사용되는 잠금은 크게 `스토리지 엔진 레벨`과 `MySQL 엔진 레벨`로 나눌 수 있음
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음
- MySQL 엔진에서는 테이블 데이터 동기화를 위한 `테이블 락(Table Lock)` 이외에도 테이블의 구조를 잠그는 `메타데이터 락(Metadata Lock)`, 사용자의 필요에 맞게 사용할 수 있는 `네임드 락(Named Lock)`이라는 잠금 기능도 제공

## 5.2.1 글로벌 락
- `글로벌 락(Global Lock)`은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있으며, MySQL에서 제공하는 잠금 가운데 가장 범위가 큼
  - `FLUSH TABLES WITH READ LOCK` 명령은 실행과 동시에 MySQL 서버에 존재하는 모든 테이블을 닫고 잠금을 검
  - 명령이 실행되기 전에 테이블이나 레코드에 쓰기 잠금을 거는 SQL이 실행됐다면 이 명령은 해당 테이블의 읽기 잠금을 걸기 위해 먼저 실행된 SQL과 그 트랜잭션이 완료될 때까지 기다려야 함
  - 장시간 실행되는 쿼리와 `FLUSH TABLES WITH READ LOCK` 명령이 최악의 케이스로 실행되면 MySQL 서버의 모든 테이블에 대한 `INSERT`, `UPDATE`, `DELETE` 쿼리가 아주 오랜 시간 동안 실행되지 못하고 기다릴 수 있음
  - 글로벌 락은 MySQL 서버의 모든 테이블에 큰 영향을 미치기 때문에 웹 서비스용으로 사용되는 MySQL 서버에서는 가급적 사용하지 않는 것이 좋음
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 `SELECT`를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남게 됨
- 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미침
- 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 `mysqldump`로 일관된 백업을 받아야 할 때는 글로벌 락 사용
- MySQL 8.0부터 트랜잭션을 지원하는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 생김
  - MySQL 8.0부터 `Xtrabackup`이나 `Enterprise Backup`과 같은 백업 툴들의 안정적인 실행을 위해 `백업 락`이 도입
    ```sql
        LOCK INSTANCE FOR BACKUP;
        -- 백업 실행
        UNLOCK INSTANCE;
    ```
  - 특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 됨
  - 하지만 일반적인 테이블의 데이터 변경은 허용
  - 백업 락은 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지하는 역할을 함

## 5.2.2 테이블 락
- `테이블 락(Table Lock)`은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있음
- 명시적으로는 `LOCK TABLES table_name [ READ | WRITE ]` 명령으로 특정 테이블의 락을 획득 가능
- 명시적으로 획득한 잠금은 `UNLOCK TABLES` 명령으로 잠금을 반납 할 수 있음
- 명시적으로 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문에 특별한 상황이 아니면 애플리케이션에서 사용하지 않는 것이 좋음
- 묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
- MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 제거하는 형태로 사용
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않음
  - InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경 쿼리(DML)에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미침

## 5.2.3 네임드 락
- `네임드 락(Named Lock)`은 `GET_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있음
    ```sql
        -- mylock이라는 문자열에 대해 잠금을 획득
        -- 이미 잠금을 사용 중이라면 2초 동안 대기, 2초 후 자동 잠금 해제
        SELECT GET_LOCK('mylock', 2);

        -- 'mylock'이라는 문자열에 대해 잠금이 설정돼 있는지 확인
        SELECT IS_FREE_LOCK('mylock');

        -- 'mylock'이라는 문자열에 대해 획득했던 잠금을 반납
        SELECT RELEASE_LOCK('mylock');
    ```
- 잠금 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아닌 것이 특징
- 네임드 락은 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금
- 자주 사용되지는 않음
- 네임드 락의 경우 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용
  - 배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 되는데, 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 해결 가능
- MySQL 8.0 버전부터는 네임드 락을 중첩해서 사용할 수 있게 됐으며, 현재 세션에서 획득한 네임드 락을 한 번에 모두 해제하는 기능도 추가됨
  - 동시에 모두 해제하고자 한다면 `RELEASE_ALL_LOCKS()` 함수 사용

## 5.2.4 메타데이터 락
- `메타데이터 락(Metadata Lock)`은 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금
- 메타데이터 락은 명시적으로 획득하거나 해제할 수 있는 것이 아니고 `RENAME TABLE table_a TO table_b` 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금
  - `RENAME TABLE` 명령의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정
```sql
    RENAME TABLE rank TO rank_backup, rank_new TO rank;
```
  - 위와 같이 하나의 RENAME TABLE 명령문에 두 개의 RENAME 작업을 한꺼번에 실행하면 오류를 발생시키지 않고 적용 가능
  - 하지만 이 문장을 2개로 나눠서 실행하면 아주 짧은 시간이지만 rank 테이블이 존재하지 않는 순간이 생기고 이때 실행되는 쿼리는 `"Table not found 'rank'"`오류를 발생